# 常见的排序算法
[toc]

## 一、 说明

常见的排序算法可以分为四类：

- 选择排序：[简单选择排序](https://github.com/hefrankeleyn/ARTS/blob/master/js_wp/SelectorSort.js) O(n^2)、[堆排序](https://github.com/hefrankeleyn/ARTS/blob/master/js_wp/HeapSort.js) O(nlogn)
- 交换排序：[冒泡排序](https://github.com/hefrankeleyn/ARTS/blob/master/js_wp/MaoPaoSort.js)O(n^2)、[快速排序](https://github.com/hefrankeleyn/ARTS/blob/master/js_wp/QuickSort.js)O(nlogn)、[三路快速排序](https://github.com/hefrankeleyn/ARTS/blob/master/js_wp/ThreeWayQuickSort.js)O(nlogn)
- 插入排序：[简单插入排序](https://github.com/hefrankeleyn/ARTS/blob/master/js_wp/InsertSort.js) O(n^2)、[希尔排序](https://github.com/hefrankeleyn/ARTS/blob/master/js_wp/ShellSort.js)O(n^3.1)
- 归并排序：[从上到下的归并排序](https://github.com/hefrankeleyn/ARTS/blob/master/js_wp/UpToBottomMergeSort.js)O(nlogn)、[从下到上的归并排序](https://github.com/hefrankeleyn/ARTS/blob/master/js_wp/BottomToUpMergeSort.js)O(nlogn)

## 二、选择排序

### 2.1 简单选择排序

```javascript
// 判断 a[i]<a[j]
function less(a, i, j) {
    if (a[i]<a[j]) {
        return true;
    } else {
        return false;
    }
}

// 交换 i 和 j的位置
function exch(a, i, j) {
    let t = a[i];
    a[i] = a[j];
    a[j] = t;
}


// 选择排序
function selectorSort(a) {
    if (a==null || a.length==0) {
        return;
    }
    for (let i=0; i<a.length-1; i++) {
        let t = i;
        for (let j=i+1; j<a.length; j++) {
            if (less(a, j, t)) {
                t = j;
            }
        }
        exch(a, t, i)
    }
}
```

### 2.2 堆排序

将序列想象成一个二叉树。

> less 和 exch 方法容易出错。

```javascript
// 堆排序
function heapSort(a) {
    if (!a || a.length==0) {
        return
    }
    // 整数与整数相除，可能得到的是小数
    let k = Math.round(a.length/2,0);
    let N = a.length;
    while (k>=1) {
        sink(a, k, N);
        k--;
    }

    while (N>1) {
        exch(a, 1, N);
        N--;
        sink(a, 1, N);
    }
}

// 堆排序的关键： 下沉
function sink(a, k, n) {
    while (k * 2 <=n) {
        let j = k * 2;
        if (j+1<=n && less(a, j, j+1)) j++;
        if (less(a, j, k)) return;
        exch(a, j, k);
        k = j;
    }
}

// 判断a[i-1] < a[j-1]
function less(a, i, j) {
    if (a[i-1]<a[j-1]) {
        return true;
    } else {
        return false;
    }
}

// 将 i-1 与 j-1 交换位置
function exch(a, i, j) {
    let t = a[i-1];
    a[i-1] = a[j-1];
    a[j-1] = t;
}
```

## 三、交换排序

### 3.1 冒泡排序

```javascript
// 冒泡排序
function maoPaoSort(a) {
    if (!a || a.length==0) {
        return;
    }
    for (let i=0; i<a.length-1; i++) {
        for (let j=1; j<a.length-i; j++) {
            if (less(a, j, j-1)) {
                exch(a, j, j-1);
            }
        }
    }
}

function less(a, i, j) {
    if (a[i]<a[j]) {
        return true;
    } else {
        return false;
    }
}

function exch(a, i, j) {
    let t = a[i];
    a[i] = a[j];
    a[j] = t;
}
```

### 3.2 快速排序

```javascript
// 快速排序
function quickSort(a) {
    if (!a || a.length ==0) {
        return;
    }
    // 优化：打乱 a 的顺序
    shuffle(a)
    sort(a, 0, a.length-1);
}

// 打乱 a 的顺序， 避免极端的情况
function shuffle(a) {
    for (let i=0; i<a.length; i++) {
        let j = Math.floor(Math.random() * (a.length-i))
        exch(a, i, i+j);
    }
}

function sort(a, lo, hi) {
    if (lo>=hi) return;
    // 分成两半，左边的都小于a[p], 右边的都大于a[p]
    let p = partition(a, lo, hi);

    sort(a, lo, p-1);
    sort(a, p+1, hi);
}

function partition(a, lo, hi) {
    let left = lo;
    let right = hi+1;
    let j = lo;
    while (left<right) {
        while (less(a, ++left, j)) if (left==hi) break;
        while (less(a, j, --right)) if (right==lo) break;
        if (left>=right) break;
        exch(a, left, right)
    }
    exch(a, j, right);
    return right;
}

function less(a, i, j) {
    if (a[i]<a[j]) {
        return true;
    } else {
        return false;
    }
}

function exch(a, i, j) {
    let t = a[i];
    a[i] = a[j];
    a[j] = t;
}
```

### 3.3 三路快速排序

适用于当有大量重复元素的时候

```javascript
// 三路快排
function threeWayQuickSort(a) {
    if (!a || a.length==0) {
        return;
    }
    shuffle(a);
    sort(a, 0, a.length-1);
}

// 打乱 a 的顺序， 避免极端的情况
function shuffle(a) {
    for (let i=0; i<a.length; i++) {
        let j = Math.floor(Math.random() * (a.length-i))
        exch(a, i, i+j);
    }
}


function sort(a, lo, hi) {
    if (lo>=hi) return;

    let eq = lo;
    let left = lo+1;
    let right = hi;
    while (left<=right) {
        if (less(a, eq, left)) {
            exch(a, left, right);
            right--;
        } else if (less(a, left, eq)) {
            exch(a, left, eq);
            eq++;
            left++;
        } else {
            left++;
        }
    }
    sort(a, lo, eq-1);
    sort(a, left, hi);
}

function less(a, i, j) {
    if (a[i]<a[j]) {
        return true;
    }else {
        return false;
    }
}

function exch(a, i, j) {
    let t = a[i];
    a[i] = a[j];
    a[j] = t; 
}

```

## 四、插入排序

### 4.1 简单插入排序

```javascript
// 插入排序
function insertSort(a) {
    if (!a || a.length == 0) {
        return;
    }
    for (let i=1; i<a.length; i++) {
        let j = i-1;
        let t = a[i];
        for (; j>=0; j--) {
            if (less(t, a[j])) {
                a[j+1] = a[j]; 
            } else {
                break;
            }
        }
        a[j+1] = t;
    }
}

function less(v1, v2) {
    if (v1<v2) {
        return true;
    } else {
        return false;
    }
}
```

### 4.2 希尔排序

基于插入排序 ，进行优化

```javascript
// 希尔排序，基于插入排序
function shellSort(a) {
    if (!a || a.length==0) {
        return;
    }
    let k = 1;
    while (k<Math.floor(a/3)) {
        k = k * 3 + 1;
    }

    while (k>=1) {
        for (let i=k; i<a.length; i++) {
            let j = i-k;
            let v = a[i];
            for (;j>=0; j-=k) {
                if (less(v, a[j])) {
                    a[j+k] = a[j];
                }else {
                    break
                }
            }
            a[j+k] = v;
        }
        k = Math.floor(k/3)
    }
}

function less(v1, v2) {
    if (v1<v2) {
        return true;
    }else {
        return false;
    }
}
```

## 五、归并排序

### 5.1 从下到上归并排序（递归）

```javascript
// 从下到上归并排序
function bottomToUpMergeSort(a) {
    if (!a || a.length==0) {
        return;
    }
    let aux = []
    for (let i=0; i<a.length; i++) {
        aux[i] = a[i];
    }
    sort(a, 0, a.length-1, aux);
}

function sort(a, lo, hi, aux) {
    if (lo>=hi) return;

    let mid = Math.floor((lo+hi)/2);
    sort(a, lo, mid, aux);
    sort(a, mid+1, hi, aux);

    merge(a, lo, mid, hi, aux);
    
}

function merge(a, lo, mid, hi, aux) {
    for (let k=lo; k<=hi; k++) {
        aux[k] = a[k];
    }
    let x = lo, y = mid+1;
    for (let k=lo; k<=hi; k++) {
        if (x>mid) a[k] = aux[y++]
        else if (y>hi) a[k] = aux[x++];
        else if (less(aux, x, y)) a[k] = aux[x++];
        else a[k] = aux[y++]
    }
}

function less(a, i, j) {
    if (a[i] < a[j]) {
        return true;
    } else {
        return false;
    }
}
```

### 5.2 从上到下归并排序（递推）

```javascript
// 从上到下归并排序 （递推）
function upToBottomMergeSort(a) {
    if (!a || a.length==0) {
        return;
    }
    let aux = []
    for (let i=0; i<a.length; i++) {
        aux[i] = i;
    }
    for (let k = 1; k<a.length; k = k*2) {
        for (let i=0; i<a.length; i = i + k * 2) {
            merge(a, i, i+k, Math.min(i+k+k-1, a.length-1), aux);
        }
    }
}

function merge(a, lo, mid, hi, aux) {
    for (let k=0; k<=hi; k++) {
        aux[k] = a[k];
    }
    let x = lo, y = mid;
    for (let k = lo; k<=hi; k++) {
        if (x>=mid) a[k] = aux[y++];
        else if (y>hi) a[k] = aux[x++];
        else if (less(aux, x, y)) a[k] = aux[x++];
        else a[k] = aux[y++];
    }
}


function less(a, i, j) {
    if (a[i]<a[j]) {
        return true;
    } else {
        return false;
    }
}
```

